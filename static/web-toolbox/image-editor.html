<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ¨çº¿å›¾ç‰‡ç¼–è¾‘å™¨ - è£åˆ‡/æ»¤é•œ/è°ƒè‰²/æ ‡æ³¨ | åœ¨çº¿å·¥å…·ç®±</title>
    <meta name="description" content="å…è´¹åœ¨çº¿å›¾ç‰‡ç¼–è¾‘å™¨ï¼Œæ”¯æŒè£åˆ‡ã€ç¿»è½¬ã€æ—‹è½¬ã€è°ƒè‰²ã€æ»¤é•œã€æ ‡æ³¨ã€æ–‡å­—æ·»åŠ ç­‰åŠŸèƒ½ã€‚æä¾›ç°åº¦ã€åè‰²ã€æ¨¡ç³Šã€é”åŒ–ã€æµ®é›•ã€åƒç´ åŒ–ç­‰ä¸°å¯Œæ»¤é•œæ•ˆæœã€‚">
    <meta name="keywords" content="å›¾ç‰‡ç¼–è¾‘,åœ¨çº¿På›¾,å›¾ç‰‡è£åˆ‡,å›¾ç‰‡æ»¤é•œ,è°ƒè‰²,æ ‡æ³¨,æ–‡å­—æ·»åŠ ,æŠ å›¾,å…è´¹å·¥å…·">
    <meta name="author" content="heyuan110">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://www.heyuan110.com/web-toolbox/image-editor.html">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ–¼ï¸</text></svg>">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.heyuan110.com/web-toolbox/image-editor.html">
    <meta property="og:title" content="åœ¨çº¿å›¾ç‰‡ç¼–è¾‘å™¨ - è£åˆ‡/æ»¤é•œ/è°ƒè‰²/æ ‡æ³¨">
    <meta property="og:description" content="å…è´¹åœ¨çº¿å›¾ç‰‡ç¼–è¾‘å™¨ï¼Œæ”¯æŒè£åˆ‡ã€æ»¤é•œã€è°ƒè‰²ã€æ ‡æ³¨ç­‰åŠŸèƒ½ã€‚">
    <meta property="og:image" content="https://www.heyuan110.com/web-toolbox/screenshots/image-editor.png">
    <meta property="og:locale" content="zh_CN">
    <meta property="og:site_name" content="Web Toolbox">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="åœ¨çº¿å›¾ç‰‡ç¼–è¾‘å™¨ - è£åˆ‡/æ»¤é•œ/è°ƒè‰²/æ ‡æ³¨">
    <meta name="twitter:description" content="å…è´¹åœ¨çº¿å›¾ç‰‡ç¼–è¾‘å™¨ï¼Œæ”¯æŒè£åˆ‡ã€æ»¤é•œã€è°ƒè‰²ã€æ ‡æ³¨ã€‚">
    <meta name="twitter:image" content="https://www.heyuan110.com/web-toolbox/screenshots/image-editor.png">

    <!-- JSON-LD -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "åœ¨çº¿å›¾ç‰‡ç¼–è¾‘å™¨",
        "url": "https://www.heyuan110.com/web-toolbox/image-editor.html",
        "description": "åœ¨çº¿å›¾ç‰‡ç¼–è¾‘å™¨ï¼Œæ”¯æŒè£åˆ‡ã€æ»¤é•œã€è°ƒè‰²ã€æ ‡æ³¨ç­‰åŠŸèƒ½",
        "applicationCategory": "DesignApplication",
        "operatingSystem": "Web Browser",
        "offers": {"@type": "Offer", "price": "0", "priceCurrency": "CNY"},
        "author": {"@type": "Person", "name": "heyuan110"}
    }
    </script>

    <!-- Cropper.js -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.6.1/dist/cropper.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-card: #0f3460;
            --bg-hover: #1a4a7a;
            --text-primary: #eee;
            --text-secondary: #aaa;
            --accent: #e94560;
            --accent-light: #ff6b6b;
            --success: #4ecdc4;
            --warning: #ffd93d;
            --border: #2a2a4a;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* å¤´éƒ¨ */
        .header {
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-card));
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo h1 {
            font-size: 1.3rem;
            background: linear-gradient(135deg, var(--accent), var(--accent-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .back-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.9rem;
        }

        .back-link:hover {
            color: var(--accent);
        }

        /* æŒ‰é’® */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-light));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(233, 69, 96, 0.3);
        }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
        }

        .btn-success {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ä¸»å¸ƒå±€ */
        .main-container {
            display: flex;
            height: calc(100vh - 60px);
        }

        /* å·¦ä¾§å·¥å…·æ  */
        .toolbar {
            width: 60px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 10px 0;
        }

        .tool-btn {
            width: 100%;
            padding: 12px 0;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            font-size: 0.7rem;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            color: var(--text-primary);
            background: var(--bg-card);
        }

        .tool-btn.active {
            color: var(--accent);
            background: var(--bg-card);
            border-left: 3px solid var(--accent);
        }

        .tool-btn .icon {
            font-size: 1.2rem;
        }

        /* ç”»å¸ƒåŒºåŸŸ */
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0a0a15;
            position: relative;
            overflow: hidden;
        }

        .canvas-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: auto;
        }

        #mainCanvas {
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        /* ä¸Šä¼ åŒºåŸŸ */
        .upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px;
            text-align: center;
        }

        .upload-box {
            border: 2px dashed var(--border);
            border-radius: 16px;
            padding: 60px 80px;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-box:hover,
        .upload-box.drag-over {
            border-color: var(--accent);
            background: rgba(233, 69, 96, 0.1);
        }

        .upload-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .upload-title {
            font-size: 1.3rem;
            margin-bottom: 10px;
        }

        .upload-desc {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* å³ä¾§é¢æ¿ */
        .panel {
            width: 280px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-section-title {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        /* æ»‘å— */
        .slider-group {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .slider-value {
            color: var(--accent);
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: var(--bg-card);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        /* æ»¤é•œç½‘æ ¼ */
        .filter-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .filter-item {
            background: var(--bg-card);
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .filter-item:hover {
            border-color: var(--border);
        }

        .filter-item.active {
            border-color: var(--accent);
        }

        .filter-preview {
            width: 100%;
            aspect-ratio: 1;
            background: linear-gradient(45deg, #666 25%, transparent 25%),
                        linear-gradient(-45deg, #666 25%, transparent 25%),
                        linear-gradient(45deg, transparent 75%, #666 75%),
                        linear-gradient(-45deg, transparent 75%, #666 75%);
            background-size: 10px 10px;
            background-position: 0 0, 0 5px, 5px -5px, -5px 0;
            border-radius: 4px;
            margin-bottom: 4px;
            overflow: hidden;
        }

        .filter-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .filter-name {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }

        /* æ“ä½œæŒ‰é’®ç»„ */
        .action-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .action-btn {
            padding: 10px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .action-btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .action-btn .icon {
            font-size: 1.2rem;
        }

        /* æ–‡å­—è¾“å…¥ */
        .text-input {
            width: 100%;
            padding: 10px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .text-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* åº•éƒ¨å·¥å…·æ  */
        .bottom-bar {
            padding: 10px 15px;
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zoom-btn {
            width: 30px;
            height: 30px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 1rem;
        }

        .zoom-btn:hover {
            background: var(--bg-hover);
        }

        .zoom-value {
            font-size: 0.85rem;
            min-width: 50px;
            text-align: center;
        }

        /* è£åˆ‡æ¨¡å¼ */
        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            z-index: 100;
        }

        .crop-overlay.active {
            display: flex;
        }

        .crop-actions {
            padding: 15px;
            background: var(--bg-secondary);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .crop-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: auto;
            min-height: 0;
        }

        .crop-container img {
            max-width: 100%;
            max-height: 100%;
        }

        .crop-ratio-btns {
            display: flex;
            gap: 8px;
        }

        .ratio-btn {
            padding: 6px 12px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.8rem;
        }

        .ratio-btn:hover,
        .ratio-btn.active {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* å†å²è®°å½• */
        .history-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: var(--bg-card);
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .history-item:hover {
            background: var(--bg-hover);
        }

        .history-item.current {
            border: 1px solid var(--accent);
        }

        /* æŠ å›¾æ¨¡å¼ */
        .chroma-controls {
            margin-top: 10px;
        }

        /* éšè—å…ƒç´  */
        .hidden {
            display: none !important;
        }

        /* å“åº”å¼ */
        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
            }

            .toolbar {
                width: 100%;
                flex-direction: row;
                overflow-x: auto;
            }

            .tool-btn {
                padding: 8px 12px;
            }

            .panel {
                width: 100%;
                max-height: 300px;
            }
        }

        /* æ–‡å­—å›¾å±‚æ ·å¼ */
        .text-layer {
            position: absolute;
            cursor: move;
            user-select: none;
            padding: 5px 10px;
            border: 2px dashed transparent;
            transition: border-color 0.2s;
        }

        .text-layer:hover,
        .text-layer.selected {
            border-color: var(--accent);
        }

        .text-layer .delete-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 20px;
            height: 20px;
            background: var(--accent);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 12px;
            display: none;
        }

        .text-layer:hover .delete-btn,
        .text-layer.selected .delete-btn {
            display: block;
        }

        #textLayerContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #textLayerContainer .text-layer {
            pointer-events: auto;
            white-space: nowrap;
        }

        /* ç»˜å›¾ç”»å¸ƒ */
        #drawCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #drawCanvas.active {
            pointer-events: auto;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <span style="font-size: 1.5rem;">ğŸ–¼ï¸</span>
            <h1>åœ¨çº¿å›¾ç‰‡ç¼–è¾‘å™¨</h1>
        </div>
        <div class="header-actions">
            <a href="index.html" class="back-link">â† è¿”å›å·¥å…·ç®±</a>
            <label for="fileInput" class="btn btn-secondary">ğŸ“‚ æ‰“å¼€å›¾ç‰‡</label>
            <button id="undoBtn" class="btn btn-secondary" disabled>â†© æ’¤é”€</button>
            <button id="redoBtn" class="btn btn-secondary" disabled>â†ª é‡åš</button>
            <button id="resetBtn" class="btn btn-secondary" disabled>ğŸ”„ é‡ç½®</button>
            <button id="downloadBtn" class="btn btn-success" disabled>ğŸ’¾ ä¿å­˜å›¾ç‰‡</button>
        </div>
    </header>

    <input type="file" id="fileInput" accept="image/*" style="display: none;">

    <main class="main-container">
        <!-- å·¦ä¾§å·¥å…·æ  -->
        <aside class="toolbar">
            <button class="tool-btn active" data-tool="adjust">
                <span class="icon">ğŸ¨</span>
                <span>è°ƒè‰²</span>
            </button>
            <button class="tool-btn" data-tool="filter">
                <span class="icon">âœ¨</span>
                <span>æ»¤é•œ</span>
            </button>
            <button class="tool-btn" data-tool="crop">
                <span class="icon">âœ‚ï¸</span>
                <span>è£åˆ‡</span>
            </button>
            <button class="tool-btn" data-tool="transform">
                <span class="icon">ğŸ”„</span>
                <span>å˜æ¢</span>
            </button>
            <button class="tool-btn" data-tool="draw">
                <span class="icon">âœï¸</span>
                <span>æ ‡æ³¨</span>
            </button>
            <button class="tool-btn" data-tool="text">
                <span class="icon">ğŸ“</span>
                <span>æ–‡å­—</span>
            </button>
            <button class="tool-btn" data-tool="chroma">
                <span class="icon">ğŸ­</span>
                <span>æŠ å›¾</span>
            </button>
        </aside>

        <!-- ç”»å¸ƒåŒºåŸŸ -->
        <section class="canvas-area">
            <div class="canvas-wrapper" id="canvasWrapper">
                <!-- ä¸Šä¼ åŒºåŸŸ -->
                <div class="upload-area" id="uploadArea">
                    <div class="upload-box" id="uploadBox">
                        <div class="upload-icon">ğŸ–¼ï¸</div>
                        <h2 class="upload-title">æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</h2>
                        <p class="upload-desc">æˆ–ç‚¹å‡»é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼ˆæ”¯æŒ JPGã€PNGã€WebPã€GIFï¼‰</p>
                    </div>
                </div>

                <!-- ä¸»ç”»å¸ƒ -->
                <canvas id="mainCanvas" class="hidden"></canvas>
                <canvas id="drawCanvas" class="hidden"></canvas>
                <!-- æ–‡å­—å›¾å±‚å®¹å™¨ -->
                <div id="textLayerContainer"></div>
            </div>

            <!-- è£åˆ‡è¦†ç›–å±‚ -->
            <div class="crop-overlay" id="cropOverlay">
                <div class="crop-actions">
                    <div class="crop-ratio-btns">
                        <button class="ratio-btn active" data-ratio="free">è‡ªç”±</button>
                        <button class="ratio-btn" data-ratio="1">1:1</button>
                        <button class="ratio-btn" data-ratio="1.333">4:3</button>
                        <button class="ratio-btn" data-ratio="1.777">16:9</button>
                        <button class="ratio-btn" data-ratio="0.75">3:4</button>
                    </div>
                    <button class="btn btn-primary" id="applyCrop">âœ“ åº”ç”¨è£åˆ‡</button>
                    <button class="btn btn-secondary" id="cancelCrop">âœ• å–æ¶ˆ</button>
                </div>
                <div class="crop-container">
                    <img id="cropImage" src="">
                </div>
            </div>

            <!-- åº•éƒ¨çŠ¶æ€æ  -->
            <div class="bottom-bar" id="bottomBar" style="display: none;">
                <div class="image-info">
                    <span id="imageDimensions">0 Ã— 0</span>
                </div>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomOut">âˆ’</button>
                    <span class="zoom-value" id="zoomValue">100%</span>
                    <button class="zoom-btn" id="zoomIn">+</button>
                    <button class="zoom-btn" id="zoomFit">âŠ¡</button>
                </div>
            </div>
        </section>

        <!-- å³ä¾§é¢æ¿ -->
        <aside class="panel" id="panel">
            <!-- è°ƒè‰²é¢æ¿ -->
            <div id="adjustPanel">
                <div class="panel-header">ğŸ¨ è°ƒè‰²</div>
                <div class="panel-content">
                    <div class="panel-section">
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>äº®åº¦</span>
                                <span class="slider-value" id="brightnessValue">0</span>
                            </div>
                            <input type="range" id="brightness" min="-100" max="100" value="0">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>å¯¹æ¯”åº¦</span>
                                <span class="slider-value" id="contrastValue">0</span>
                            </div>
                            <input type="range" id="contrast" min="-100" max="100" value="0">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>é¥±å’Œåº¦</span>
                                <span class="slider-value" id="saturationValue">0</span>
                            </div>
                            <input type="range" id="saturation" min="-100" max="100" value="0">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>è‰²è°ƒ</span>
                                <span class="slider-value" id="hueValue">0</span>
                            </div>
                            <input type="range" id="hue" min="-180" max="180" value="0">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>æ›å…‰</span>
                                <span class="slider-value" id="exposureValue">0</span>
                            </div>
                            <input type="range" id="exposure" min="-100" max="100" value="0">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>å™ªç‚¹</span>
                                <span class="slider-value" id="noiseValue">0</span>
                            </div>
                            <input type="range" id="noise" min="0" max="100" value="0">
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ»¤é•œé¢æ¿ -->
            <div id="filterPanel" class="hidden">
                <div class="panel-header">âœ¨ æ»¤é•œ</div>
                <div class="panel-content">
                    <div class="filter-grid" id="filterGrid">
                        <!-- æ»¤é•œé¡¹ç›®ç”± JS ç”Ÿæˆ -->
                    </div>
                </div>
            </div>

            <!-- è£åˆ‡é¢æ¿ -->
            <div id="cropPanel" class="hidden">
                <div class="panel-header">âœ‚ï¸ è£åˆ‡</div>
                <div class="panel-content">
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 15px;">
                        ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®è¿›å…¥è£åˆ‡æ¨¡å¼ï¼Œæ‹–æ‹½è°ƒæ•´è£åˆ‡åŒºåŸŸ
                    </p>
                    <button class="btn btn-primary" id="startCrop" style="width: 100%;">å¼€å§‹è£åˆ‡</button>
                </div>
            </div>

            <!-- å˜æ¢é¢æ¿ -->
            <div id="transformPanel" class="hidden">
                <div class="panel-header">ğŸ”„ å˜æ¢</div>
                <div class="panel-content">
                    <div class="panel-section">
                        <div class="panel-section-title">ç¿»è½¬</div>
                        <div class="action-grid">
                            <button class="action-btn" id="flipH">
                                <span class="icon">â†”ï¸</span>
                                <span>æ°´å¹³ç¿»è½¬</span>
                            </button>
                            <button class="action-btn" id="flipV">
                                <span class="icon">â†•ï¸</span>
                                <span>å‚ç›´ç¿»è½¬</span>
                            </button>
                        </div>
                    </div>
                    <div class="panel-section">
                        <div class="panel-section-title">æ—‹è½¬</div>
                        <div class="action-grid">
                            <button class="action-btn" id="rotateL">
                                <span class="icon">â†º</span>
                                <span>å·¦æ—‹90Â°</span>
                            </button>
                            <button class="action-btn" id="rotateR">
                                <span class="icon">â†»</span>
                                <span>å³æ—‹90Â°</span>
                            </button>
                        </div>
                    </div>
                    <div class="panel-section">
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>è‡ªç”±æ—‹è½¬</span>
                                <span class="slider-value" id="rotateValue">0Â°</span>
                            </div>
                            <input type="range" id="rotateSlider" min="-180" max="180" value="0">
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ ‡æ³¨é¢æ¿ -->
            <div id="drawPanel" class="hidden">
                <div class="panel-header">âœï¸ æ ‡æ³¨</div>
                <div class="panel-content">
                    <div class="panel-section">
                        <div class="panel-section-title">å·¥å…·</div>
                        <div class="action-grid">
                            <button class="action-btn active" data-draw="brush">
                                <span class="icon">ğŸ–Œï¸</span>
                                <span>ç”»ç¬”</span>
                            </button>
                            <button class="action-btn" data-draw="line">
                                <span class="icon">ğŸ“</span>
                                <span>ç›´çº¿</span>
                            </button>
                            <button class="action-btn" data-draw="rect">
                                <span class="icon">â¬œ</span>
                                <span>çŸ©å½¢</span>
                            </button>
                            <button class="action-btn" data-draw="circle">
                                <span class="icon">â­•</span>
                                <span>åœ†å½¢</span>
                            </button>
                            <button class="action-btn" data-draw="arrow">
                                <span class="icon">â¡ï¸</span>
                                <span>ç®­å¤´</span>
                            </button>
                            <button class="action-btn" data-draw="eraser">
                                <span class="icon">ğŸ§½</span>
                                <span>æ©¡çš®</span>
                            </button>
                        </div>
                    </div>
                    <div class="panel-section">
                        <div class="color-picker-wrapper">
                            <input type="color" id="drawColor" value="#e94560">
                            <span>ç”»ç¬”é¢œè‰²</span>
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>ç”»ç¬”å¤§å°</span>
                                <span class="slider-value" id="brushSizeValue">5</span>
                            </div>
                            <input type="range" id="brushSize" min="1" max="50" value="5">
                        </div>
                    </div>
                    <button class="btn btn-secondary" id="clearDraw" style="width: 100%;">æ¸…é™¤æ ‡æ³¨</button>
                </div>
            </div>

            <!-- æ–‡å­—é¢æ¿ -->
            <div id="textPanel" class="hidden">
                <div class="panel-header">ğŸ“ æ–‡å­—</div>
                <div class="panel-content">
                    <div class="panel-section">
                        <input type="text" class="text-input" id="textInput" placeholder="è¾“å…¥æ–‡å­—å†…å®¹...">
                        <div class="color-picker-wrapper">
                            <input type="color" id="textColor" value="#ffffff">
                            <span>æ–‡å­—é¢œè‰²</span>
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>å­—ä½“å¤§å°</span>
                                <span class="slider-value" id="fontSizeValue">32</span>
                            </div>
                            <input type="range" id="fontSize" min="12" max="120" value="32">
                        </div>
                        <select class="text-input" id="fontFamily">
                            <option value="Arial">Arial</option>
                            <option value="Microsoft YaHei">å¾®è½¯é›…é»‘</option>
                            <option value="SimHei">é»‘ä½“</option>
                            <option value="SimSun">å®‹ä½“</option>
                            <option value="KaiTi">æ¥·ä½“</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Courier New">Courier New</option>
                        </select>
                        <div style="margin-top: 10px;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="textBold"> ç²—ä½“
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-top: 8px;">
                                <input type="checkbox" id="textShadow"> é˜´å½±
                            </label>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="addText" style="width: 100%;">æ·»åŠ æ–‡å­—</button>
                    <p style="color: var(--text-secondary); font-size: 0.8rem; margin-top: 10px; text-align: center;">
                        ğŸ’¡ æ·»åŠ åå¯æ‹–åŠ¨æ–‡å­—è°ƒæ•´ä½ç½®
                    </p>
                    <button class="btn btn-secondary" id="clearText" style="width: 100%; margin-top: 10px;">æ¸…é™¤æ‰€æœ‰æ–‡å­—</button>
                </div>
            </div>

            <!-- æŠ å›¾é¢æ¿ -->
            <div id="chromaPanel" class="hidden">
                <div class="panel-header">ğŸ­ çº¯è‰²æŠ å›¾</div>
                <div class="panel-content">
                    <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 15px;">
                        é€‰æ‹©è¦å»é™¤çš„èƒŒæ™¯é¢œè‰²ï¼Œè°ƒæ•´å®¹å·®å€¼ä½¿æŠ å›¾æ•ˆæœæ›´è‡ªç„¶
                    </p>
                    <div class="panel-section">
                        <div class="color-picker-wrapper">
                            <input type="color" id="chromaColor" value="#00ff00">
                            <span>é€‰æ‹©èƒŒæ™¯è‰²</span>
                        </div>
                        <button class="btn btn-secondary" id="pickColor" style="width: 100%; margin-bottom: 10px;">
                            ğŸ¯ ä»å›¾ç‰‡å–è‰²
                        </button>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>å®¹å·®</span>
                                <span class="slider-value" id="chromaToleranceValue">30</span>
                            </div>
                            <input type="range" id="chromaTolerance" min="0" max="100" value="30">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>è¾¹ç¼˜ç¾½åŒ–</span>
                                <span class="slider-value" id="chromaFeatherValue">0</span>
                            </div>
                            <input type="range" id="chromaFeather" min="0" max="20" value="0">
                        </div>
                    </div>
                    <button class="btn btn-primary" id="applyChroma" style="width: 100%;">åº”ç”¨æŠ å›¾</button>
                </div>
            </div>
        </aside>
    </main>

    <!-- Cropper.js -->
    <script src="https://cdn.jsdelivr.net/npm/cropperjs@1.6.1/dist/cropper.min.js"></script>

    <script>
        // ========== çŠ¶æ€ç®¡ç† ==========
        const state = {
            originalImage: null,
            currentImage: null,
            history: [],
            historyIndex: -1,
            zoom: 1,
            currentTool: 'adjust',
            adjustments: {
                brightness: 0,
                contrast: 0,
                saturation: 0,
                hue: 0,
                exposure: 0,
                noise: 0
            },
            currentFilter: 'none',
            rotation: 0,
            flipH: false,
            flipV: false,
            textLayers: [],
            drawTool: 'brush',
            drawColor: '#e94560',
            brushSize: 5,
            isDrawing: false,
            cropper: null,
            isPickingColor: false
        };

        // ========== DOM å…ƒç´  ==========
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const uploadBox = document.getElementById('uploadBox');
        const mainCanvas = document.getElementById('mainCanvas');
        const drawCanvas = document.getElementById('drawCanvas');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const ctx = mainCanvas.getContext('2d', { willReadFrequently: true });
        const drawCtx = drawCanvas.getContext('2d');
        const bottomBar = document.getElementById('bottomBar');

        // ========== æ»¤é•œå®šä¹‰ ==========
        const filters = [
            { id: 'none', name: 'åŸå›¾', apply: null },
            { id: 'grayscale', name: 'ç°åº¦', apply: (d) => applyGrayscale(d) },
            { id: 'invert', name: 'åè‰²', apply: (d) => applyInvert(d) },
            { id: 'sepia', name: 'æ£•è¤', apply: (d) => applySepia(d) },
            { id: 'vintage', name: 'å¤å¤', apply: (d) => applyVintage(d) },
            { id: 'cold', name: 'å†·è°ƒ', apply: (d) => applyCold(d) },
            { id: 'warm', name: 'æš–è°ƒ', apply: (d) => applyWarm(d) },
            { id: 'blur', name: 'æ¨¡ç³Š', apply: (d, c) => applyBlur(d, c) },
            { id: 'sharpen', name: 'é”åŒ–', apply: (d, c) => applySharpen(d, c) },
            { id: 'emboss', name: 'æµ®é›•', apply: (d, c) => applyEmboss(d, c) },
            { id: 'pixelate', name: 'åƒç´ åŒ–', apply: (d, c) => applyPixelate(d, c) },
            { id: 'edge', name: 'è¾¹ç¼˜', apply: (d, c) => applyEdge(d, c) }
        ];

        // ========== åˆå§‹åŒ– ==========
        function init() {
            setupEventListeners();
            generateFilterGrid();
        }

        function setupEventListeners() {
            // æ–‡ä»¶ä¸Šä¼ 
            fileInput.addEventListener('change', handleFileSelect);
            uploadBox.addEventListener('click', () => fileInput.click());
            uploadBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadBox.classList.add('drag-over');
            });
            uploadBox.addEventListener('dragleave', () => uploadBox.classList.remove('drag-over'));
            uploadBox.addEventListener('drop', handleDrop);

            // å·¥å…·åˆ‡æ¢
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', () => switchTool(btn.dataset.tool));
            });

            // è°ƒè‰²æ»‘å—
            ['brightness', 'contrast', 'saturation', 'hue', 'exposure', 'noise'].forEach(param => {
                const slider = document.getElementById(param);
                slider.addEventListener('input', () => {
                    state.adjustments[param] = parseInt(slider.value);
                    document.getElementById(`${param}Value`).textContent = slider.value;
                    applyAllEffects();
                });
            });

            // å˜æ¢æŒ‰é’®
            document.getElementById('flipH').addEventListener('click', () => { state.flipH = !state.flipH; applyAllEffects(); saveHistory('æ°´å¹³ç¿»è½¬'); });
            document.getElementById('flipV').addEventListener('click', () => { state.flipV = !state.flipV; applyAllEffects(); saveHistory('å‚ç›´ç¿»è½¬'); });
            document.getElementById('rotateL').addEventListener('click', () => rotate(-90));
            document.getElementById('rotateR').addEventListener('click', () => rotate(90));
            document.getElementById('rotateSlider').addEventListener('input', (e) => {
                state.rotation = parseInt(e.target.value);
                document.getElementById('rotateValue').textContent = state.rotation + 'Â°';
                applyAllEffects();
            });
            document.getElementById('rotateSlider').addEventListener('change', () => saveHistory('æ—‹è½¬'));

            // è£åˆ‡
            document.getElementById('startCrop').addEventListener('click', startCrop);
            document.getElementById('applyCrop').addEventListener('click', applyCrop);
            document.getElementById('cancelCrop').addEventListener('click', cancelCrop);
            document.querySelectorAll('.ratio-btn').forEach(btn => {
                btn.addEventListener('click', () => setCropRatio(btn.dataset.ratio));
            });

            // æ ‡æ³¨
            document.querySelectorAll('[data-draw]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-draw]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.drawTool = btn.dataset.draw;
                });
            });
            document.getElementById('drawColor').addEventListener('input', (e) => state.drawColor = e.target.value);
            document.getElementById('brushSize').addEventListener('input', (e) => {
                state.brushSize = parseInt(e.target.value);
                document.getElementById('brushSizeValue').textContent = e.target.value;
            });
            document.getElementById('clearDraw').addEventListener('click', clearDrawCanvas);

            // ç»˜å›¾ç”»å¸ƒäº‹ä»¶
            drawCanvas.addEventListener('mousedown', startDrawing);
            drawCanvas.addEventListener('mousemove', draw);
            drawCanvas.addEventListener('mouseup', stopDrawing);
            drawCanvas.addEventListener('mouseleave', stopDrawing);

            // æ–‡å­—
            document.getElementById('fontSize').addEventListener('input', (e) => {
                document.getElementById('fontSizeValue').textContent = e.target.value;
            });
            document.getElementById('addText').addEventListener('click', addTextLayer);
            document.getElementById('clearText').addEventListener('click', clearTextLayers);

            // æŠ å›¾
            document.getElementById('chromaTolerance').addEventListener('input', (e) => {
                document.getElementById('chromaToleranceValue').textContent = e.target.value;
            });
            document.getElementById('chromaFeather').addEventListener('input', (e) => {
                document.getElementById('chromaFeatherValue').textContent = e.target.value;
            });
            document.getElementById('pickColor').addEventListener('click', startPickColor);
            document.getElementById('applyChroma').addEventListener('click', applyChromaKey);

            // å–è‰²æ¨¡å¼
            mainCanvas.addEventListener('click', handleCanvasClick);

            // é¡¶éƒ¨æŒ‰é’®
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            document.getElementById('resetBtn').addEventListener('click', reset);
            document.getElementById('downloadBtn').addEventListener('click', download);

            // ç¼©æ”¾
            document.getElementById('zoomIn').addEventListener('click', () => setZoom(state.zoom + 0.1));
            document.getElementById('zoomOut').addEventListener('click', () => setZoom(state.zoom - 0.1));
            document.getElementById('zoomFit').addEventListener('click', fitToView);
        }

        // ========== æ–‡ä»¶å¤„ç† ==========
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) loadImage(file);
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadBox.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) loadImage(file);
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    state.originalImage = img;
                    state.currentImage = img;
                    initCanvas(img);
                    uploadArea.classList.add('hidden');
                    mainCanvas.classList.remove('hidden');
                    bottomBar.style.display = 'flex';
                    enableButtons();
                    saveHistory('æ‰“å¼€å›¾ç‰‡');
                    fitToView();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function initCanvas(img) {
            mainCanvas.width = img.width;
            mainCanvas.height = img.height;
            drawCanvas.width = img.width;
            drawCanvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            document.getElementById('imageDimensions').textContent = `${img.width} Ã— ${img.height}`;
        }

        // ========== å·¥å…·åˆ‡æ¢ ==========
        function switchTool(tool) {
            state.currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });

            // åˆ‡æ¢é¢æ¿
            document.querySelectorAll('#panel > div').forEach(panel => panel.classList.add('hidden'));
            document.getElementById(`${tool}Panel`).classList.remove('hidden');

            // ç»˜å›¾æ¨¡å¼
            drawCanvas.classList.toggle('active', tool === 'draw');
            drawCanvas.classList.toggle('hidden', !state.originalImage);
        }

        // ========== è°ƒè‰²å’Œæ»¤é•œ ==========
        function applyAllEffects() {
            if (!state.originalImage) return;

            // åˆ›å»ºä¸´æ—¶ç”»å¸ƒå¤„ç†å˜æ¢
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            let width = state.originalImage.width;
            let height = state.originalImage.height;

            // å¤„ç†90åº¦æ—‹è½¬
            const rot = ((state.rotation % 360) + 360) % 360;
            if (rot === 90 || rot === 270) {
                tempCanvas.width = height;
                tempCanvas.height = width;
            } else {
                tempCanvas.width = width;
                tempCanvas.height = height;
            }

            tempCtx.save();
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate(state.rotation * Math.PI / 180);
            tempCtx.scale(state.flipH ? -1 : 1, state.flipV ? -1 : 1);
            tempCtx.drawImage(state.originalImage, -width / 2, -height / 2);
            tempCtx.restore();

            // è·å–åƒç´ æ•°æ®
            let imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

            // åº”ç”¨è°ƒè‰²
            applyAdjustments(imageData);

            // åº”ç”¨æ»¤é•œ
            const filter = filters.find(f => f.id === state.currentFilter);
            if (filter && filter.apply) {
                imageData = filter.apply(imageData, tempCanvas) || imageData;
            }

            // æ›´æ–°ä¸»ç”»å¸ƒ
            mainCanvas.width = tempCanvas.width;
            mainCanvas.height = tempCanvas.height;
            drawCanvas.width = tempCanvas.width;
            drawCanvas.height = tempCanvas.height;
            ctx.putImageData(imageData, 0, 0);

            document.getElementById('imageDimensions').textContent = `${mainCanvas.width} Ã— ${mainCanvas.height}`;
        }

        function applyAdjustments(imageData) {
            const data = imageData.data;
            const { brightness, contrast, saturation, hue, exposure, noise } = state.adjustments;

            for (let i = 0; i < data.length; i += 4) {
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];

                // äº®åº¦
                r += brightness * 2.55;
                g += brightness * 2.55;
                b += brightness * 2.55;

                // æ›å…‰
                const expFactor = Math.pow(2, exposure / 50);
                r *= expFactor;
                g *= expFactor;
                b *= expFactor;

                // å¯¹æ¯”åº¦
                const contrastFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                r = contrastFactor * (r - 128) + 128;
                g = contrastFactor * (g - 128) + 128;
                b = contrastFactor * (b - 128) + 128;

                // é¥±å’Œåº¦å’Œè‰²è°ƒ
                if (saturation !== 0 || hue !== 0) {
                    let [h, s, l] = rgbToHsl(r, g, b);
                    s = Math.max(0, Math.min(1, s + saturation / 100));
                    h = (h + hue / 360 + 1) % 1;
                    [r, g, b] = hslToRgb(h, s, l);
                }

                // å™ªç‚¹
                if (noise > 0) {
                    const n = (Math.random() - 0.5) * noise * 2.55;
                    r += n;
                    g += n;
                    b += n;
                }

                data[i] = Math.max(0, Math.min(255, r));
                data[i + 1] = Math.max(0, Math.min(255, g));
                data[i + 2] = Math.max(0, Math.min(255, b));
            }
        }

        // ========== æ»¤é•œæ•ˆæœ ==========
        function applyGrayscale(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                data[i] = data[i + 1] = data[i + 2] = gray;
            }
            return imageData;
        }

        function applyInvert(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2];
            }
            return imageData;
        }

        function applySepia(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
            }
            return imageData;
        }

        function applyVintage(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.1 + 20);
                data[i + 1] = Math.min(255, data[i + 1] * 0.9 + 10);
                data[i + 2] = Math.min(255, data[i + 2] * 0.8);
            }
            return imageData;
        }

        function applyCold(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.max(0, data[i] - 20);
                data[i + 2] = Math.min(255, data[i + 2] + 30);
            }
            return imageData;
        }

        function applyWarm(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] + 30);
                data[i + 2] = Math.max(0, data[i + 2] - 20);
            }
            return imageData;
        }

        function applyConvolution(imageData, canvas, kernel, divisor = 1) {
            const data = imageData.data;
            const w = canvas.width;
            const h = canvas.height;
            const output = new Uint8ClampedArray(data);
            const kSize = Math.sqrt(kernel.length);
            const half = Math.floor(kSize / 2);

            for (let y = half; y < h - half; y++) {
                for (let x = half; x < w - half; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let ky = 0; ky < kSize; ky++) {
                        for (let kx = 0; kx < kSize; kx++) {
                            const idx = ((y + ky - half) * w + (x + kx - half)) * 4;
                            const k = kernel[ky * kSize + kx];
                            r += data[idx] * k;
                            g += data[idx + 1] * k;
                            b += data[idx + 2] * k;
                        }
                    }
                    const idx = (y * w + x) * 4;
                    output[idx] = Math.max(0, Math.min(255, r / divisor + 128));
                    output[idx + 1] = Math.max(0, Math.min(255, g / divisor + 128));
                    output[idx + 2] = Math.max(0, Math.min(255, b / divisor + 128));
                }
            }
            imageData.data.set(output);
            return imageData;
        }

        function applyBlur(imageData, canvas) {
            const kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];
            const data = imageData.data;
            const w = canvas.width;
            const h = canvas.height;
            const output = new Uint8ClampedArray(data);

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * w + (x + kx)) * 4;
                            const k = kernel[(ky + 1) * 3 + (kx + 1)];
                            r += data[idx] * k;
                            g += data[idx + 1] * k;
                            b += data[idx + 2] * k;
                        }
                    }
                    const idx = (y * w + x) * 4;
                    output[idx] = r / 16;
                    output[idx + 1] = g / 16;
                    output[idx + 2] = b / 16;
                }
            }
            imageData.data.set(output);
            return imageData;
        }

        function applySharpen(imageData, canvas) {
            const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
            const data = imageData.data;
            const w = canvas.width;
            const h = canvas.height;
            const output = new Uint8ClampedArray(data);

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * w + (x + kx)) * 4;
                            const k = kernel[(ky + 1) * 3 + (kx + 1)];
                            r += data[idx] * k;
                            g += data[idx + 1] * k;
                            b += data[idx + 2] * k;
                        }
                    }
                    const idx = (y * w + x) * 4;
                    output[idx] = Math.max(0, Math.min(255, r));
                    output[idx + 1] = Math.max(0, Math.min(255, g));
                    output[idx + 2] = Math.max(0, Math.min(255, b));
                }
            }
            imageData.data.set(output);
            return imageData;
        }

        function applyEmboss(imageData, canvas) {
            const kernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2];
            return applyConvolution(imageData, canvas, kernel, 1);
        }

        function applyEdge(imageData, canvas) {
            const kernel = [-1, -1, -1, -1, 8, -1, -1, -1, -1];
            const data = imageData.data;
            const w = canvas.width;
            const h = canvas.height;
            const output = new Uint8ClampedArray(data);

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * w + (x + kx)) * 4;
                            const k = kernel[(ky + 1) * 3 + (kx + 1)];
                            r += data[idx] * k;
                            g += data[idx + 1] * k;
                            b += data[idx + 2] * k;
                        }
                    }
                    const idx = (y * w + x) * 4;
                    const val = Math.abs(r) + Math.abs(g) + Math.abs(b);
                    output[idx] = output[idx + 1] = output[idx + 2] = Math.min(255, val);
                }
            }
            imageData.data.set(output);
            return imageData;
        }

        function applyPixelate(imageData, canvas) {
            const data = imageData.data;
            const w = canvas.width;
            const h = canvas.height;
            const size = Math.max(4, Math.floor(Math.min(w, h) / 50));

            for (let y = 0; y < h; y += size) {
                for (let x = 0; x < w; x += size) {
                    const idx = (y * w + x) * 4;
                    const r = data[idx], g = data[idx + 1], b = data[idx + 2];

                    for (let dy = 0; dy < size && y + dy < h; dy++) {
                        for (let dx = 0; dx < size && x + dx < w; dx++) {
                            const i = ((y + dy) * w + (x + dx)) * 4;
                            data[i] = r;
                            data[i + 1] = g;
                            data[i + 2] = b;
                        }
                    }
                }
            }
            return imageData;
        }

        // ========== æ»¤é•œé€‰æ‹©å™¨ ==========
        function generateFilterGrid() {
            const grid = document.getElementById('filterGrid');
            grid.innerHTML = filters.map(f => `
                <div class="filter-item ${f.id === 'none' ? 'active' : ''}" data-filter="${f.id}">
                    <div class="filter-preview">
                        <div style="width:100%;height:100%;background:linear-gradient(135deg,#667eea,#764ba2);"></div>
                    </div>
                    <div class="filter-name">${f.name}</div>
                </div>
            `).join('');

            grid.querySelectorAll('.filter-item').forEach(item => {
                item.addEventListener('click', () => {
                    grid.querySelectorAll('.filter-item').forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    state.currentFilter = item.dataset.filter;
                    applyAllEffects();
                    saveHistory(`æ»¤é•œ: ${filters.find(f => f.id === state.currentFilter).name}`);
                });
            });
        }

        // ========== å˜æ¢ ==========
        function rotate(deg) {
            state.rotation = (state.rotation + deg + 360) % 360;
            document.getElementById('rotateSlider').value = state.rotation;
            document.getElementById('rotateValue').textContent = state.rotation + 'Â°';
            applyAllEffects();
            saveHistory(`æ—‹è½¬ ${deg}Â°`);
        }

        // ========== è£åˆ‡ ==========
        function startCrop() {
            if (!state.originalImage) return;

            const overlay = document.getElementById('cropOverlay');
            const cropImage = document.getElementById('cropImage');

            cropImage.src = mainCanvas.toDataURL();
            overlay.classList.add('active');

            if (state.cropper) state.cropper.destroy();

            state.cropper = new Cropper(cropImage, {
                viewMode: 1,
                dragMode: 'move',
                autoCropArea: 0.8,
                responsive: true,
                background: false
            });
        }

        function setCropRatio(ratio) {
            document.querySelectorAll('.ratio-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');

            if (state.cropper) {
                state.cropper.setAspectRatio(ratio === 'free' ? NaN : parseFloat(ratio));
            }
        }

        function applyCrop() {
            if (!state.cropper) return;

            const croppedCanvas = state.cropper.getCroppedCanvas();
            const img = new Image();
            img.onload = () => {
                state.originalImage = img;
                initCanvas(img);
                applyAllEffects();
                saveHistory('è£åˆ‡');
                cancelCrop();
            };
            img.src = croppedCanvas.toDataURL();
        }

        function cancelCrop() {
            if (state.cropper) {
                state.cropper.destroy();
                state.cropper = null;
            }
            document.getElementById('cropOverlay').classList.remove('active');
        }

        // ========== æ ‡æ³¨ç»˜å›¾ ==========
        let drawStart = { x: 0, y: 0 };

        function startDrawing(e) {
            if (state.currentTool !== 'draw') return;
            state.isDrawing = true;

            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;
            drawStart.x = (e.clientX - rect.left) * scaleX;
            drawStart.y = (e.clientY - rect.top) * scaleY;

            if (state.drawTool === 'brush' || state.drawTool === 'eraser') {
                drawCtx.beginPath();
                drawCtx.moveTo(drawStart.x, drawStart.y);
            }
        }

        function draw(e) {
            if (!state.isDrawing) return;

            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            drawCtx.lineWidth = state.brushSize;
            drawCtx.lineCap = 'round';
            drawCtx.lineJoin = 'round';

            if (state.drawTool === 'brush') {
                drawCtx.strokeStyle = state.drawColor;
                drawCtx.globalCompositeOperation = 'source-over';
                drawCtx.lineTo(x, y);
                drawCtx.stroke();
            } else if (state.drawTool === 'eraser') {
                drawCtx.globalCompositeOperation = 'destination-out';
                drawCtx.lineTo(x, y);
                drawCtx.stroke();
            }
        }

        function stopDrawing(e) {
            if (!state.isDrawing) return;
            state.isDrawing = false;

            if (['line', 'rect', 'circle', 'arrow'].includes(state.drawTool)) {
                const rect = drawCanvas.getBoundingClientRect();
                const scaleX = drawCanvas.width / rect.width;
                const scaleY = drawCanvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                drawCtx.strokeStyle = state.drawColor;
                drawCtx.lineWidth = state.brushSize;
                drawCtx.globalCompositeOperation = 'source-over';

                if (state.drawTool === 'line') {
                    drawCtx.beginPath();
                    drawCtx.moveTo(drawStart.x, drawStart.y);
                    drawCtx.lineTo(x, y);
                    drawCtx.stroke();
                } else if (state.drawTool === 'rect') {
                    drawCtx.strokeRect(drawStart.x, drawStart.y, x - drawStart.x, y - drawStart.y);
                } else if (state.drawTool === 'circle') {
                    const rx = Math.abs(x - drawStart.x) / 2;
                    const ry = Math.abs(y - drawStart.y) / 2;
                    const cx = drawStart.x + (x - drawStart.x) / 2;
                    const cy = drawStart.y + (y - drawStart.y) / 2;
                    drawCtx.beginPath();
                    drawCtx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                    drawCtx.stroke();
                } else if (state.drawTool === 'arrow') {
                    drawArrow(drawStart.x, drawStart.y, x, y);
                }
            }

            drawCtx.beginPath();
        }

        function drawArrow(fromX, fromY, toX, toY) {
            const headLen = state.brushSize * 3;
            const angle = Math.atan2(toY - fromY, toX - fromX);

            drawCtx.beginPath();
            drawCtx.moveTo(fromX, fromY);
            drawCtx.lineTo(toX, toY);
            drawCtx.stroke();

            drawCtx.beginPath();
            drawCtx.moveTo(toX, toY);
            drawCtx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
            drawCtx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
            drawCtx.closePath();
            drawCtx.fillStyle = state.drawColor;
            drawCtx.fill();
        }

        function clearDrawCanvas() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        }

        // ========== æ–‡å­— ==========
        const textLayerContainer = document.getElementById('textLayerContainer');
        let textLayerId = 0;

        function addTextLayer() {
            const text = document.getElementById('textInput').value.trim();
            if (!text || !state.originalImage) return;

            const color = document.getElementById('textColor').value;
            const size = document.getElementById('fontSize').value;
            const font = document.getElementById('fontFamily').value;
            const bold = document.getElementById('textBold').checked;
            const shadow = document.getElementById('textShadow').checked;

            // åˆ›å»ºæ–‡å­—å›¾å±‚ DOM å…ƒç´ 
            const layer = document.createElement('div');
            layer.className = 'text-layer';
            layer.id = `text-layer-${textLayerId++}`;
            layer.textContent = text;
            layer.style.cssText = `
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                color: ${color};
                font-size: ${size}px;
                font-family: ${font};
                font-weight: ${bold ? 'bold' : 'normal'};
                ${shadow ? 'text-shadow: 2px 2px 4px rgba(0,0,0,0.5);' : ''}
            `;

            // åˆ é™¤æŒ‰é’®
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = 'Ã—';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                layer.remove();
                state.textLayers = state.textLayers.filter(l => l.id !== layer.id);
            };
            layer.appendChild(deleteBtn);

            // ä¿å­˜åˆ°çŠ¶æ€
            const layerData = {
                id: layer.id,
                text, color, size: parseInt(size), font, bold, shadow,
                x: 0.5, y: 0.5  // ç›¸å¯¹ä½ç½®ï¼ˆ0-1ï¼‰
            };
            state.textLayers.push(layerData);

            // æ‹–åŠ¨åŠŸèƒ½
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            layer.addEventListener('mousedown', (e) => {
                if (e.target === deleteBtn) return;
                isDragging = true;
                layer.classList.add('selected');
                startX = e.clientX;
                startY = e.clientY;
                const rect = layer.getBoundingClientRect();
                const containerRect = textLayerContainer.getBoundingClientRect();
                startLeft = rect.left - containerRect.left + rect.width / 2;
                startTop = rect.top - containerRect.top + rect.height / 2;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const containerRect = textLayerContainer.getBoundingClientRect();
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                const newLeft = startLeft + dx;
                const newTop = startTop + dy;

                layer.style.left = newLeft + 'px';
                layer.style.top = newTop + 'px';
                layer.style.transform = 'translate(-50%, -50%)';

                // æ›´æ–°ç›¸å¯¹ä½ç½®
                layerData.x = newLeft / containerRect.width;
                layerData.y = newTop / containerRect.height;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    layer.classList.remove('selected');
                }
            });

            textLayerContainer.appendChild(layer);
            document.getElementById('textInput').value = '';
        }

        // å°†æ–‡å­—å›¾å±‚ç»˜åˆ¶åˆ°ç”»å¸ƒï¼ˆä¿å­˜æ—¶è°ƒç”¨ï¼‰
        function renderTextLayersToCanvas() {
            const containerRect = textLayerContainer.getBoundingClientRect();
            const canvasRect = mainCanvas.getBoundingClientRect();
            const scaleX = mainCanvas.width / canvasRect.width;
            const scaleY = mainCanvas.height / canvasRect.height;

            state.textLayers.forEach(layerData => {
                const layer = document.getElementById(layerData.id);
                if (!layer) return;

                const rect = layer.getBoundingClientRect();
                const x = (rect.left - canvasRect.left + rect.width / 2) * scaleX;
                const y = (rect.top - canvasRect.top + rect.height / 2) * scaleY;

                ctx.font = `${layerData.bold ? 'bold ' : ''}${layerData.size * scaleX}px ${layerData.font}`;
                ctx.fillStyle = layerData.color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (layerData.shadow) {
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowBlur = 4 * scaleX;
                    ctx.shadowOffsetX = 2 * scaleX;
                    ctx.shadowOffsetY = 2 * scaleY;
                }

                ctx.fillText(layerData.text, x, y);

                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            });
        }

        // æ¸…é™¤æ–‡å­—å›¾å±‚
        function clearTextLayers() {
            textLayerContainer.innerHTML = '';
            state.textLayers = [];
        }

        // ========== æŠ å›¾ ==========
        function startPickColor() {
            state.isPickingColor = true;
            mainCanvas.style.cursor = 'crosshair';
            alert('è¯·ç‚¹å‡»å›¾ç‰‡ä¸Šè¦å»é™¤çš„èƒŒæ™¯é¢œè‰²');
        }

        function handleCanvasClick(e) {
            if (!state.isPickingColor) return;

            const rect = mainCanvas.getBoundingClientRect();
            const scaleX = mainCanvas.width / rect.width;
            const scaleY = mainCanvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);

            const pixel = ctx.getImageData(x, y, 1, 1).data;
            const hex = '#' + [pixel[0], pixel[1], pixel[2]].map(v => v.toString(16).padStart(2, '0')).join('');

            document.getElementById('chromaColor').value = hex;
            state.isPickingColor = false;
            mainCanvas.style.cursor = 'default';
        }

        function applyChromaKey() {
            if (!state.originalImage) return;

            const color = document.getElementById('chromaColor').value;
            const tolerance = parseInt(document.getElementById('chromaTolerance').value);
            const feather = parseInt(document.getElementById('chromaFeather').value);

            const targetR = parseInt(color.slice(1, 3), 16);
            const targetG = parseInt(color.slice(3, 5), 16);
            const targetB = parseInt(color.slice(5, 7), 16);

            const imageData = ctx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                const diff = Math.sqrt(
                    Math.pow(r - targetR, 2) +
                    Math.pow(g - targetG, 2) +
                    Math.pow(b - targetB, 2)
                );

                if (diff < tolerance * 4.4) {
                    if (feather > 0 && diff > (tolerance - feather) * 4.4) {
                        data[i + 3] = Math.floor(255 * (diff - (tolerance - feather) * 4.4) / (feather * 4.4));
                    } else {
                        data[i + 3] = 0;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            saveHistory('æŠ å›¾');
        }

        // ========== å†å²è®°å½• ==========
        function saveHistory(action) {
            // åˆå¹¶æ ‡æ³¨å›¾å±‚
            const combined = document.createElement('canvas');
            combined.width = mainCanvas.width;
            combined.height = mainCanvas.height;
            const combCtx = combined.getContext('2d');
            combCtx.drawImage(mainCanvas, 0, 0);
            combCtx.drawImage(drawCanvas, 0, 0);

            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push({
                action,
                data: combined.toDataURL(),
                adjustments: { ...state.adjustments },
                filter: state.currentFilter,
                rotation: state.rotation,
                flipH: state.flipH,
                flipV: state.flipV
            });
            state.historyIndex = state.history.length - 1;

            updateHistoryButtons();
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                restoreHistory();
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                restoreHistory();
            }
        }

        function restoreHistory() {
            const entry = state.history[state.historyIndex];
            const img = new Image();
            img.onload = () => {
                mainCanvas.width = img.width;
                mainCanvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                drawCanvas.width = img.width;
                drawCanvas.height = img.height;
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

                // æ¢å¤çŠ¶æ€
                state.adjustments = { ...entry.adjustments };
                state.currentFilter = entry.filter;
                state.rotation = entry.rotation;
                state.flipH = entry.flipH;
                state.flipV = entry.flipV;

                // æ›´æ–°UI
                Object.keys(state.adjustments).forEach(key => {
                    const slider = document.getElementById(key);
                    if (slider) {
                        slider.value = state.adjustments[key];
                        document.getElementById(`${key}Value`).textContent = state.adjustments[key];
                    }
                });
                document.getElementById('rotateSlider').value = state.rotation;
                document.getElementById('rotateValue').textContent = state.rotation + 'Â°';
            };
            img.src = entry.data;
            updateHistoryButtons();
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = state.historyIndex <= 0;
            document.getElementById('redoBtn').disabled = state.historyIndex >= state.history.length - 1;
        }

        function reset() {
            if (!state.originalImage || !confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰ä¿®æ”¹å—ï¼Ÿ')) return;

            state.adjustments = { brightness: 0, contrast: 0, saturation: 0, hue: 0, exposure: 0, noise: 0 };
            state.currentFilter = 'none';
            state.rotation = 0;
            state.flipH = false;
            state.flipV = false;

            // é‡ç½®UI
            Object.keys(state.adjustments).forEach(key => {
                const slider = document.getElementById(key);
                if (slider) {
                    slider.value = 0;
                    document.getElementById(`${key}Value`).textContent = '0';
                }
            });
            document.getElementById('rotateSlider').value = 0;
            document.getElementById('rotateValue').textContent = '0Â°';
            document.querySelectorAll('.filter-item').forEach(i => i.classList.remove('active'));
            document.querySelector('.filter-item[data-filter="none"]').classList.add('active');

            clearDrawCanvas();
            clearTextLayers();
            initCanvas(state.originalImage);
            saveHistory('é‡ç½®');
        }

        // ========== ç¼©æ”¾ ==========
        function setZoom(z) {
            state.zoom = Math.max(0.1, Math.min(3, z));
            mainCanvas.style.transform = `scale(${state.zoom})`;
            drawCanvas.style.transform = `scale(${state.zoom})`;
            textLayerContainer.style.transform = `scale(${state.zoom})`;
            document.getElementById('zoomValue').textContent = Math.round(state.zoom * 100) + '%';
        }

        function fitToView() {
            const wrapper = canvasWrapper.getBoundingClientRect();
            const scaleX = (wrapper.width - 40) / mainCanvas.width;
            const scaleY = (wrapper.height - 40) / mainCanvas.height;
            setZoom(Math.min(scaleX, scaleY, 1));
        }

        // ========== ä¸‹è½½ ==========
        function download() {
            // åˆå¹¶æ‰€æœ‰å›¾å±‚
            const combined = document.createElement('canvas');
            combined.width = mainCanvas.width;
            combined.height = mainCanvas.height;
            const combCtx = combined.getContext('2d');
            combCtx.drawImage(mainCanvas, 0, 0);
            combCtx.drawImage(drawCanvas, 0, 0);

            // ç»˜åˆ¶æ–‡å­—å›¾å±‚
            const canvasRect = mainCanvas.getBoundingClientRect();
            const scaleX = mainCanvas.width / canvasRect.width;
            const scaleY = mainCanvas.height / canvasRect.height;

            state.textLayers.forEach(layerData => {
                const layer = document.getElementById(layerData.id);
                if (!layer) return;

                const rect = layer.getBoundingClientRect();
                const x = (rect.left - canvasRect.left + rect.width / 2) * scaleX;
                const y = (rect.top - canvasRect.top + rect.height / 2) * scaleY;

                combCtx.font = `${layerData.bold ? 'bold ' : ''}${layerData.size * scaleX}px ${layerData.font}`;
                combCtx.fillStyle = layerData.color;
                combCtx.textAlign = 'center';
                combCtx.textBaseline = 'middle';

                if (layerData.shadow) {
                    combCtx.shadowColor = 'rgba(0,0,0,0.5)';
                    combCtx.shadowBlur = 4 * scaleX;
                    combCtx.shadowOffsetX = 2 * scaleX;
                    combCtx.shadowOffsetY = 2 * scaleY;
                }

                combCtx.fillText(layerData.text, x, y);

                combCtx.shadowColor = 'transparent';
                combCtx.shadowBlur = 0;
                combCtx.shadowOffsetX = 0;
                combCtx.shadowOffsetY = 0;
            });

            const link = document.createElement('a');
            link.download = 'edited-image.png';
            link.href = combined.toDataURL('image/png');
            link.click();
        }

        function enableButtons() {
            document.getElementById('resetBtn').disabled = false;
            document.getElementById('downloadBtn').disabled = false;
        }

        // ========== å·¥å…·å‡½æ•° ==========
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return [h, s, l];
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [r * 255, g * 255, b * 255];
        }

        // å¯åŠ¨
        init();
    </script>
</body>
</html>
